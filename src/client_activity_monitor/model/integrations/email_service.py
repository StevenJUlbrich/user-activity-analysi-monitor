import webbrowser
from urllib.parse import quote
from datetime import datetime
from typing import List, Optional
import pandas as pd
from pathlib import Path
from loguru import logger

class EmailService:
    """
    Handles email generation using mailto URLs.
    Opens default email client with pre-filled information.
    """
    
    def __init__(self):
        """Initialize email service."""
        self.max_body_length = 2000  # Most email clients have URL length limits
        
    def create_email_draft(
        self,
        recipients: List[str],
        report_data: pd.DataFrame,
        report_path: Path,
        user_sid: str,
        last_event_time: datetime
    ) -> bool:
        """
        Create email draft using mailto URL.
        
        Args:
            recipients: List of email addresses
            report_data: DataFrame with report results
            report_path: Path to Excel report file
            user_sid: SID of user who generated report
            last_event_time: Last event time used for analysis
            
        Returns:
            True if email client opened successfully
        """
        try:
            # Generate subject
            subject = self._generate_subject(len(report_data), last_event_time)
            
            # Generate body
            body = self._generate_body(
                report_data,
                report_path,
                user_sid,
                last_event_time
            )
            
            # Create mailto URL
            mailto_url = self._create_mailto_url(recipients, subject, body)
            
            # Open in default email client
            webbrowser.open(mailto_url)
            
            logger.info(f"Email draft created for {len(recipients)} recipients")
            return True
            
        except Exception as e:
            logger.error(f"Failed to create email draft: {e}")
            return False
            
    def _generate_subject(self, user_count: int, last_event_time: datetime) -> str:
        """Generate email subject line."""
        date_str = last_event_time.strftime("%Y-%m-%d")
        if user_count > 0:
            return f"User Activity Report - {user_count} Users Flagged - {date_str}"
        else:
            return f"User Activity Report - No Users Flagged - {date_str}"
            
    def _generate_body(
        self,
        report_data: pd.DataFrame,
        report_path: Path,
        user_sid: str,
        last_event_time: datetime
    ) -> str:
        """
        Generate email body with report summary.
        """
        lines = [
            "User Activity Analysis Report",
            "=" * 40,
            "",
            f"Generated By: {user_sid}",
            f"Generated At: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"Analysis Period: 24 hours before {last_event_time.strftime('%Y-%m-%d %H:%M')}",
            "",
            "SUMMARY",
            "-" * 20,
        ]
        
        if report_data.empty:
            lines.extend([
                "No users found meeting all criteria.",
                "",
                "Criteria: Users must have all four change types (password, email, phone, token) "
                "within the 24-hour analysis window."
            ])
        else:
            lines.extend([
                f"Total Users Flagged: {len(report_data)}",
                "",
                "These users have made ALL of the following changes within the last 24 hours:",
                "  • Password change",
                "  • Email change",
                "  • Phone number change",
                "  • Security token change",
                "",
                "USER LIST",
                "-" * 20,
            ])
            
            # Add user summary (limit to prevent URL length issues)
            max_users_in_email = 20
            for idx, row in report_data.head(max_users_in_email).iterrows():
                user_line = f"• {row['user_id']}"
                
                # Add change summary if space allows
                if 'earliest_change' in row and 'latest_change' in row:
                    earliest = pd.to_datetime(row['earliest_change']).strftime('%H:%M')
                    latest = pd.to_datetime(row['latest_change']).strftime('%H:%M')
                    user_line += f" (changes between {earliest} - {latest})"
                    
                lines.append(user_line)
                
            if len(report_data) > max_users_in_email:
                lines.append(f"... and {len(report_data) - max_users_in_email} more users")
                
        lines.extend([
            "",
            "ACTIONS REQUIRED",
            "-" * 20,
            "1. Review the attached Excel report for complete details",
            "2. Investigate flagged users for potential security concerns",
            "3. Document findings in the incident tracking system",
            "",
            "ATTACHMENT REQUIRED",
            "-" * 20,
            f"Please manually attach the report file:",
            f"{report_path.name}",
            "",
            f"The report file path has been copied to your clipboard.",
            f"Full path: {report_path.absolute()}",
            "",
            "---",
            "This is an automated report from the User Activity Monitor system.",
        ])
        
        return '\n'.join(lines)
        
    def _create_mailto_url(
        self,
        recipients: List[str],
        subject: str,
        body: str
    ) -> str:
        """
        Create properly formatted mailto URL.
        """
        # Join recipients with semicolon (works for most email clients)
        to_string = ';'.join(recipients)
        
        # URL encode subject and body
        subject_encoded = quote(subject)
        body_encoded = quote(body)
        
        # Check URL length and truncate body if needed
        base_url = f"mailto:{to_string}?subject={subject_encoded}&body="
        available_length = self.max_body_length - len(base_url)
        
        if len(body_encoded) > available_length:
            # Truncate body and add note
            truncate_note = "\n\n[Email body truncated due to length limits]"
            truncated_body = body[:available_length - len(quote(truncate_note)) - 100]
            body_encoded = quote(truncated_body + truncate_note)
            logger.warning("Email body truncated due to URL length limits")
            
        mailto_url = f"{base_url}{body_encoded}"
        
        return mailto_url
        
    def format_html_table(self, report_data: pd.DataFrame, max_rows: int = 10) -> str:
        """
        Format DataFrame as HTML table for email (if needed for future enhancement).
        Currently not used due to mailto limitations.
        """
        if report_data.empty:
            return "<p>No data available</p>"
            
        # Select subset of columns for email
        display_columns = ['user_id', 'earliest_change', 'latest_change', 'change_window_hours']
        available_columns = [col for col in display_columns if col in report_data.columns]
        
        subset = report_data[available_columns].head(max_rows)
        
        html = subset.to_html(
            index=False,
            table_id="report-table",
            classes="report-table",
            escape=False
        )
        
        if len(report_data) > max_rows:
            html += f"<p><i>... and {len(report_data) - max_rows} more users</i></p>"
            
        return html